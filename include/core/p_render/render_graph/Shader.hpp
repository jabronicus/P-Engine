#pragma once

#include "../../p_render/backend/shaders/ShaderModule.hpp"

#include <vector>
#include <string>
#include <memory>

class ImageResource;
class BufferResource;
class RenderGraph;

class Shader {
  public:
    Shader(const std::string &subpassName, const std::string &shaderName, std::shared_ptr<RenderGraph> graph); // probably need to give a graph handle
    ~Shader() = default;

    const std::string &getSubpassName() const {
        return subpassName_;
    }

    const std::string &getShaderName() {
        return shaderName_;
    }

    std::shared_ptr<Backend::ShaderModule> &getModule() {
        return shaderModule_;
    }

    // i think i need something like this, so we can set our descriptor bindings:
    void setDescriptorSetBinding(const std::string &resourceName, unsigned int descriptorSet, unsigned int bindingSlot) {
        if (bindings_.find(resourceName) != bindings_.end()) {
            // i'll make it so that you can set multiple times and it'll update if the values are different
            if (descriptorSet != bindings_[resourceName].setNumber || bindingSlot != bindings_[resourceName].bindingNumber) {
                // if the supplied set+binding are different from what exists, go through and erase all existing bindings
                // (there should only be one at a time but i'll do it this way to be sure)
                auto itr = bindings_.find(resourceName);
                while (itr != bindings_.end()) {
                    bindings_.erase(itr);
                }
                // after erasing, we set the new binding according to what we were given
                bindings_[resourceName] = {
                    descriptorSet,
                    bindingSlot
                };
            }
            // otherwise the supplied bindings are the same and we don't do anything
            return;
        }
        
        // in this case, the binding does not exist so we just add it immediately 
        bindings_[resourceName] = {
            descriptorSet,
            bindingSlot
        };
    }


  private:
    // whatever high-level info is required for shaders
    std::shared_ptr<RenderGraph> graph_;

    std::string subpassName_;
    std::string shaderName_;

    // since each unique resource should only really appear in one list, we can just map names to
    // bindings directly
    struct DescriptorSetBinding {
        unsigned int setNumber = ~0u; // stores the descriptor set index that the resource is bound to
        unsigned int bindingNumber = ~0u; // stores the binding slot within the set
    };
    std::map<std::string, DescriptorSetBinding> bindings_;

    std::shared_ptr<Backend::ShaderModule> shaderModule_ = nullptr;

    /* Resources */
        // shaders can have a few different types of resources, and these
        // should correspond to some existing render graph resources
    
    // IMAGES    
    // storage images (an image that can be written to (in contrast to sampled images, which can't be written to)),
    std::vector<std::string> storageImageInputs_;
    std::vector<std::string> storageImageOutputs_;

    // input attachments (special type of image whose content is generated by earlier operations on the same image in a graphics pipeline)
    std::vector<std::string> inputAttachments_;

    // BUFFERS:
    // uniform buffer (like texel buffer except UNFORMATTED, data is described via structures defined in the shader)
    std::vector<std::string> uniformBuffers_;
    
    // uniform texel buffer (a VkBuffer filled with homogeneous formatted read-only data) 
    std::vector<std::string> uniformTexelBuffers_;

    // storage texel buffer (contains homogeneous formatted read-write data)
    std::vector<std::string> storageTexelBufferInputs_;
    std::vector<std::string> storageTexelBufferOutputs_;
    
    // storage buffer (like the texel buffer except unformatted, similarly to uniform buffer)
    std::vector<std::string> storageBufferInputs_;
    std::vector<std::string> storageBufferOutputs_;

};
